/**
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 */

def longRangeInclusive(first: BigInt, last: BigInt) = new Iterator[BigInt] {
  private var i = first
  def hasNext = i <= last
  def next = {val r = i; i += 1; r}
}

def divisors(a: BigInt) = {
  longRangeInclusive(1, a / 2).filter(a % _ == 0).toList :+ a
}

def getPrimeFactors(composite: BigInt):List[BigInt] = {
  longRangeInclusive(2, composite).filter(composite % _ == 0).take(1).toList.flatMap { x =>
    if (x == composite) {
      List(composite)
    }
    else {
      getPrimeFactors(x) ::: getPrimeFactors(composite / x)
    }
  }
}

def triangleSequence(a: BigInt, idx: BigInt): Stream[BigInt] = {
  a #:: triangleSequence(a + idx, idx + 1)
}

val divisorCount = 500

// Quite a slow version. Took more than a couple of hour to find a triangle number with more than 500 divisors.
// triangleSequence(1, 2).dropWhile(divisors(_).length <= divisorCount).take(1)(0)

// Faster version.
// Every divisor of a number n is a linear combination (with coefficients of 0 or 1) of n's prime factors.
triangleSequence(1, 2).map(a => {
  val primeFactors = getPrimeFactors(a)
  (a, (1 to primeFactors.length).flatMap(primeFactors.combinations(_)).filter(_.product <= a).length + 1)
}).dropWhile(_._2 <= divisorCount).take(1)(0)
